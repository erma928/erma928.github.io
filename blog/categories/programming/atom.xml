<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: programming | 季米风]]></title>
  <link href="http://www.fengjimin.com/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://www.fengjimin.com/"/>
  <updated>2019-01-22T16:36:22+08:00</updated>
  <id>http://www.fengjimin.com/</id>
  <author>
    <name><![CDATA[冯继敏]]></name>
    <email><![CDATA[joe5338.cn@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[python machine learning and text processing (1)]]></title>
    <link href="http://www.fengjimin.com/blog/2019/01/22/python-machine-learning-and-text-processing-1/"/>
    <updated>2019-01-22T15:32:00+08:00</updated>
    <id>http://www.fengjimin.com/blog/2019/01/22/python-machine-learning-and-text-processing-1</id>
    <content type="html"><![CDATA[<h3>前言</h3>

<p>近期在学习python和机器学习。其实本人大学时学过不少机器学习相关专业课，包括神经网络，计算视觉与图像处理，模式识别，自然语言处理（NLP）等。也做过相关研究，读了些paper。可以说有一定基础。只是工作之后没有特意往这个方向发展，不自觉走入了被各种业务需求埋没的境地。如今AI大热，自己也对这块兴趣盎然，因而特别想在理论和实践上弄通。</p>

<p>若干年以前，因Ruby on Rails快速开发的特性，自己曾把ruby当作银弹，很痴迷于这门语言。也看了很多python与ruby谁更强大这方面的争论。当时觉得ruby的表达能力很强大且优美，近乎魔术，而python，光使用缩进语法这一点就觉得有点怪，因而并没有深入去学。虽然其解决问题有且只有一条推荐思路的理念听起来有些道理。然而世事难料，随着Rails渐趋冷静，ruby似乎也渐趋没落。而python，随着人工智能的兴起却在走向潮头。当然，自己现在来学python，已经没有了当初的门户之见，反倒很容易的见识到python简单易用，以及确实强大的方面。在大数据和人工智能的浪潮中，python能站在前沿，是有它的独到之处的。</p>

<p>本blog主要对python文本处理基础，以及机器学习相关的内容进行提纲挈领。其中文本处理包含了分词、自然语言统计、可视化、数据分析等python库。而机器学习，则包含其理论分野、实现步骤、基本机器学习算法和python库等。</p>

<p>以下为文本处理基础库相关内容。</p>

<h3>分词</h3>

<ol>
<li><p>jieba 中文分词库</p>

<ol>
<li>cut, lcut</li>
<li>load_userdict(file)</li>
<li>jieba.posseg.cut</li>
</ol>
</li>
<li><p>正则词频统计</p>

<ol>
<li><p><code>words = re.findall(r'[\u4e00-\u9fa5]+', test)</code> 匹配中文正则</p></li>
<li><p>```python
for word in wordset:
    if len(word)>1 :
        freq = wordlist.count(word)
        result.append((word, freq))</p>

<h1>[(w1,freq1),(w2,freq2)&hellip;.]</h1>

<h1>对词频统计结果进行排序</h1>

<p>new_result = sorted(result, key=lambda k:k[1], reverse=True)
```</p></li>
</ol>
</li>
</ol>


<h3>自然语言统计</h3>

<ol>
<li><p>nltk 自然语言处理库</p>

<ol>
<li><p>nltk.text.Text类</p>

<ol>
<li><code>text = Text(wordlist)</code></li>
<li><code>text.concordance(word='汪淼', width=20, lines=10)</code> 上下文</li>
<li><code>text.similar(word='叶文洁', num=10)</code>上下文最相关词</li>
<li><code>text.count(word='叶文洁')</code> 统计词频</li>
<li><code>text.dispersion_plot(words)</code> 离散图，横坐标表示词语的索引位置</li>
</ol>
</li>
<li><p>Ngrams的实现</p>

<ol>
<li><code>nltk.util.bigrams(seq), trigrams(seq), ngrams(seq, n), skipgrams(seq, n, k)</code></li>
</ol>
</li>
<li><p>nltk.probability</p>

<ol>
<li><p>FreqDist</p>

<ol>
<li><code>fdist = FreqDist(wordlist)</code></li>
<li><code>fdist.items()</code> 词频对</li>
<li><code>fdist.N()</code> 词语总数</li>
<li><code>fdist.max()</code> 词语总数</li>
<li><code>fdist.freq('三体')</code> 词频占比</li>
<li><code>fdist['三体']</code> 词频</li>
<li><code>fdist.plot(20,cumulative=True)</code> 前20个词画图</li>
</ol>
</li>
<li><p>ConditionFreqDist 带条件的频率分布类</p>

<ol>
<li><p><code>python
cfd = ConditionalFreqDist(
         [(conditon1, event1),(conditon2, event1),(conditon1, event2)...(conditon_n, event_n)]
       )
</code></p></li>
<li><p>```python
cfd = ConditionalFreqDist(
         (file, word)
         for file in files   <br/>
         for word in text_split(file))</p>

<pre><code>#计算前10大词在各类文本中的频数
cfd.tabulate(conditions=files, samples=words)
</code></pre>

<p>```</p></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>


<h3>可视化</h3>

<ol>
<li><p>pyecharts &ndash; 动态交互可视化库</p>

<ol>
<li>Bar, Bar3D, Pie, Map, &hellip;</li>
</ol>


<p>```python
&ldquo;&rdquo;&ldquo;
kwargs为通用配置项
&rdquo;&ldquo;&rdquo;
add(name, x_axis, y_axis, data,
    grid3d_opacity=1,
    grid3d_shading=&lsquo;color&rsquo;, **kwargs)</p>

<p>from pyecharts import Bar3D</p>

<p>bar3d = Bar3D(&ldquo;3D 柱状图示例&rdquo;, width=1200, height=600
              &hellip;
              &hellip;
bar3d.add(
    &ldquo;&rdquo;,
    x_axis,
    y_axis,
    [[d[1], d[0], d[2]] for d in data],
    is_visualmap=True,
    visual_range=[0, 20],
    visual_range_color=range_color,
    grid3d_width=200,
    grid3d_depth=80,
)
bar3d.render(&lsquo;html/3D_Bar.html&rsquo;)
```</p>

<ol>
<li>WordCloud</li>
</ol>


<p>```python
&ldquo;&rdquo;&ldquo;
name str图例名称
attr list属性名称
value    list属性所对应的值
&rdquo;&ldquo;&rdquo;
add(name, attr, value,
    shape=&ldquo;circle&rdquo;,
    word_gap=20,
    word_size_range=None,
    rotate_step=45)</p>

<p>from pyecharts import WordCloud
words = [&lsquo;Python&rsquo;, &lsquo;文本分析&rsquo;, &lsquo;编程&rsquo;]
freqs = [100,200,50]
wordcloud = WordCloud(width=1300, height=620)
wordcloud.add(&ldquo;&rdquo;, words, freqs, word_size_range=[20, 100])
wordcloud.render(&lsquo;html/wordcloud.html&rsquo;)
```</p></li>
</ol>


<h3>数据分析库</h3>

<ol>
<li><p>pandas</p>

<ol>
<li><p>Series</p>

<ol>
<li>Series(list), Series(dict)</li>
<li>notnull, s2>2, s2[s2>2]</li>
<li>数学运算</li>
<li>value_counts(normalize=False)</li>
<li>head, tail, sample</li>
<li>plot(kind=&lsquo;bar&rsquo;)</li>
</ol>
</li>
<li><p>DataFrame</p>

<ol>
<li><p>列向量和行向量组成的数据结构</p></li>
<li><p>```python
import numpy as np
import pandas as pd</p>

<p>df = pd.DataFrame(np.arange(40).reshape(8,5),
                 index=[&lsquo;one&rsquo;,&lsquo;two&rsquo;,&lsquo;three&rsquo;,&lsquo;four&rsquo;,&lsquo;five&rsquo;,&lsquo;six&rsquo;,&lsquo;seven&rsquo;,&lsquo;eight&rsquo;],
                 columns=[&lsquo;a&rsquo;,&lsquo;b&rsquo;,&lsquo;c&rsquo;,&rsquo;d',&lsquo;e&rsquo;])
```</p></li>
<li><p><code>df.drop('one', axis='rows', inplace=False)</code></p></li>
<li><p><code>df['a']</code>, <code>df.a</code> &ndash; 索引列名称</p></li>
<li><p><code>df.index</code> &ndash; 行索引</p></li>
<li><p><code>df[:3]</code> &ndash; 行索引查询</p></li>
<li><p><code>df.loc[['two','three'], ['a','d']]</code> &ndash; 子DataFrame查询</p></li>
<li><p><code>df.loc[:, ['a','d']]</code>, <code>df[['a', 'd']]</code> &ndash; 所有行, a,d 列</p></li>
<li><p><code>df.loc[['two','three'], :]</code> &ndash; 所有列</p></li>
<li><p><code>df.describe()</code></p></li>
<li><p><code>df['colname'] = 10009</code> &ndash; 新建或更新列</p></li>
<li><p>列方向进行<strong>聚合运算</strong></p>

<p><code>python
df.agg({'colname1': ['mean', diyfunc],
       'colname2': ['mean', 'sum']})
</code></p>

<ol>
<li><code>df.agg('mean')</code>&ndash; 针对所有列的聚合操作</li>
</ol>
</li>
<li><p>针对值进行分组 &ndash; <strong>groupby</strong></p>

<ol>
<li><code>df.set_index('date').groupby('name')['ext price'].resample("M").sum()</code> &ndash; 针对name列的值进行分组</li>
<li><code>df.groupby(['name', pd.Grouper(key='date', freq='M')])['ext price'].sum()</code></li>
<li><code>df.groupby('violation_raw').search_conducted.agg(['mean', 'count'])</code></li>
</ol>
</li>
<li><p><code>newdf=df+100</code></p></li>
<li><p><code>newdf&gt;120</code></p></li>
<li><p><code>df[newdf&gt;120]</code></p></li>
<li><p><strong>时间操作</strong></p>

<ol>
<li><p>pd.date_range() 生成一个时间段索引</p>

<ol>
<li><code>pd.date_range('2017/10/11 10:00:01', '20181030', freq='3M')</code></li>
</ol>
</li>
<li><p>pd.to_datetime(data) 将data序列数据转换为datetime类型Series</p>

<ol>
<li><code>python
datatime = pd.to_datetime(data)
datatime.dt.year
datatime.dt.month.value_counts()
</code></li>
</ol>
</li>
<li><p>指定日期为索引</p>

<ol>
<li><code>python
tm_rng = pd.date_range('2017-12-31 12:00:00',periods=20, freq='5H')
tm_series = pd.Series(np.random.randn(len(tm_rng)), index=tm_rng)
tm_series['2017']
</code></li>
</ol>
</li>
<li><p>resample</p>

<ol>
<li><code>df.set_index('date').resample('2M')['ext price'].sum()</code></li>
</ol>
</li>
</ol>
</li>
<li><p>读取csv或excell文件为dataFrame</p>

<ol>
<li><code>df = pd.read_excel('data/sample-salesv3.xlsx', encoding='gbk')</code></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>


<h3></h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅谈软件开发]]></title>
    <link href="http://www.fengjimin.com/blog/2013/09/02/an-engineers-view-of-application-development/"/>
    <updated>2013-09-02T20:47:00+08:00</updated>
    <id>http://www.fengjimin.com/blog/2013/09/02/an-engineers-view-of-application-development</id>
    <content type="html"><![CDATA[<blockquote><p>第一篇日志写于2013年。2015年的今日，经历一个充实的互联网业务的开发周期，回头看看，理解又有不同。说到底软件开发是定义问题，解决问题，二者合一。开发的过程绝不仅仅是写代码，测试，上线，支持。而是始终围绕其中的一个主题：用户、业务、产品、开发，各种角色不断沟通，提出各自理解，以各种形式如描叙、图表、代码、产品、UI、体验。。。这一切的一切，都是软件开发的一部分，每一个部分，都有同样的重要性，都可以遵循同样的方法论。最终的目标，是所有stakeholder达到一致的理解，从而从中得到自己想要的价值。</p></blockquote>

<!--more-->


<blockquote><p>另一方面，目前主流软件开发的模式，是面向对象编程，是基于OOP之上的设计模式。这是基础思想方法，是开发人员赖以搭高楼、赖以组装赛车的百宝箱。面向对象主要的思想来源，在于概念的不同抽象层次，对应了父类子类关系，既符合重用原则，也更符合人类思维。
当然，现实由于其复杂性，各种问题各种关连。从现实的问题中找到最基本最具重要性的维度来抽象，这需要一个匠人的直觉。这也是软件开发最有趣最激动人心的部分。没有武功秘籍，没有万能钥匙。真正有的，只存乎一心。。。</p></blockquote>

<p>从大学学编程开始，到如今学习工作的经验也有十多年了。记得大学毕业一、二年的时候和两个朋友讨论到同批不少同学转行去做金融，表达了羡慕之情，但那两个朋友异口同声的说其实我还蛮适合做IT的。姑且当作他们发现我身上适合搞IT做软件的特质吧。既然在这一行坚持了下来，也有必要做一个总结回顾，目的是从经验教训中找到规律，得到一个更清晰的视野。</p>

<p>软件开发，如同建房子、文艺创作，是创造的活动。任何创造的活动，需要工具，也需要想象力，完成一个复杂的项目则需要多人协作。创造，也是左脑和右脑协作的结果。左脑负责计算，逻辑推理，右脑负责情景想象，左右脑合作，才能做出符合需求、同时保证质量的产品。</p>

<p>关乎右脑想象力的方面，在建筑行业，想象力比较容易得到实物参照，一栋三维的建筑模型可以把成品外形模仿得八九不离十。而创作文学、绘画、音乐，是对现实的描叙或理念的抽象，似乎更关乎右脑记忆和情感的功能。而软件的设计，则是要满足用户的信息和功能的需求，这种需求难以有固化的实物参照，是一种概念的抽象和概念关系的梳理，且需要精确固化；它也不像文学和音乐可以有生动的现实做参照、表达的理念不需要精确。</p>

<p>另一方面关乎左脑的逻辑推理。一个建筑工程需要对工程涉及的各要素如人力、材料等进行必要测算，技术方面主要是结构力学和工程管理的应用。文艺的创作是对文字或绘画、音乐元素的组合，需要的是有对运用这些元素进行自我表达的感觉(Feel)。而软件的设计开发，需要把握编程语言，功能框架（函数库），运行机理，以及合理运用他们来表达清晰的概念关系，其最终产品不仅需要面向终端用户，也需要面向技术人员（包括自己），保证可维护和可扩展。</p>

<p>需求实现是应用开发的缘起。可以根据操作信息的不同类型、面向用户提供的功能进行分类，比如多媒体应用，网络应用，游戏应用，大数据应用，等等。在我多年应用开发的经验中，需求的理解是重要一环。其难点是需求与所运用技术的要求或限制的清晰区分。往往在思考需求的时候，缺乏经验的程序员会与所要运用的技术实现的要求和限制混为一谈。比如 Java deploy 的环境要求。只需要记住，所有的需求都是面向软件用户的。这种需求是完全独立于实现的语言或者框架的，可以用更高级的语言（甚至自然语言）来进行表达的。</p>

<p>大多数应用可以分为前端和后端来开发，也就可以运用MVC模式（视图-模型-控制器）。为保证维护性和可扩展性，需要使用DRY和正交设计的等等原则。本文和以后的系列博文，我将根据自己应用开发的经验，对不同需求的应用开发过程进行总结，尽量找到内在规律，推广到普遍软件开发的工作中，提高效率和质量。</p>
]]></content>
  </entry>
  
</feed>
